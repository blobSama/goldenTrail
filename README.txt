שלב 1
4. ניתן לוודא כי המוצר מוסר תשובות נכונות ע"י ביצוע בדיקות ולידציה השוללות נתונים שאינם עומדים
בתנאים הדרושים 
מקרי קצה אפשריים הם אי הכנסת נתונים(נציג הודעת שגיאה), הכנסת נתונים לא אפשריים, כמו פלוסים 
ומינוסים(סינון פשוט של נתונים) והכנסת נתונים שיפגעו ביורה עצמו(זווית של 90/0 אפשר לפתור ע"י סינון ספציפי).

5. נתחשב בסביבה ובתנועה אפשרית של המטרה. אפשר להתחשב בציפורים שעפות בסביבה, בתוואי הקרקע, בהתנגדות האוויר,
ברוח, ובתנועת המטרה בכיוונים שונים.


שלב 2
4. אצור מיקרו סרביס שמאזין לבקשות HTTP - בקשת GET עם פרמטרים(שהם בעצם הinput שלנו), והתשובה שהוא מחזיר היא תשובת HTTP 
עם תוצאות החישוב. ניתן לשים את המיקרו סרביס המדובר בסביבת קוברנטיס אם נצטרך.


6. במקרה שנשלחה הודעת חישוב לא צפויה, המיקרו סרביס פשוט יחזיר הודעת שגיאת HTTP.

7. ניתן להגן על הנתונים שבמערכת על ידי העברתם מעל פרוטוקול מוצפן(SSL), וכך גם אם מישהו "מאזין" לנתונים, הוא יראה מידע מוצפן, 
ולא יידע מה המידע האמיתי.

8. ניתן ליצור מנגנון Cache - כיוון שבעבור קלטים זהים תתקבל תשובה זהה, נוכל להחזיק מבנה נתונים בעבור כל שלשה של קלטים,
ונבצע בו בדיקה כדי לחפש התאמה(תשובה בעבור הנתונים שקיימת במערכת. אם ישנה התאמה, נשלוף את הנתונים, ואם אין - נבצע את
החישוב ה"כבד".

9. נשתמש במנגנון autoscaling בקוברנטיס - כאשר ישנו שימוש מרבי במעבד, המנגנון מייצר instanceים נוספים של המיקרו סרביס וכך
מתמודד עם שימוש אינטנסיבי(כמות בקשות גדולה).


שלב 3
4. נשים דגש על פשטות הממשק ועל הודעות ברורות(שיהיה ברור מה זה בדיוק כל חלק בממשק).




******************************
רציתי לומר שהתרגיל היה מאוד מעניין ומהנה. לצערי אני לא התנסיתי בקוברנטיס, ולא הספקתי להעלות את הסרביס שלי לסביבת  k8s
במסגרת הזמן שהייתה. יחד עם זאת, היה לי מאוד כיף ללמוד על קוברנטיס ולהבין את הרעיון מאחורי זה.